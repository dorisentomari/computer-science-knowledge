# 1. 可执行文件的生成

链接的功能是将所有关联的可重定位目标文件组合起来，以生成一个可执行文件。

可重定位目标文件和可执行目标文件都是机器语言目标文件，但是可重定位目标文件是单个模块生成的，可执行目标文件是多个模块组合而成的。因而可重定位目标文件代码总是从 0 开始，可执行目标文件代码在操作系统规定的虚拟地址空间中产生。

可重定位目标文件和可执行目标文件都是都不是可以直接显示的文本文件，而是不可显示的二进制文件，他们都按照一定的格式以二进制字节序列构成一种目标文件，其中包含二进制代码区、只读数据区、已初始化数据区和未初始化数据区等。每个信息区称为一个节(section)，如代码节(.text)、只读数据节(.rodata)、已初始化全局数据节(.data)和未初始化全局数据节(.bss)等。

静态链接器在将多个可重定位目标文件组合成一个可执行目标文件时，主要完成两个任务：

**符号解析(symbol resolution)** 符号解析的目的是将每个符号的因哟经与一个确定的符号定义建立关联。程序中有被定义和被引用的符号，这些符号包括变量名和函数名。编译器将所有符号存放在可重定位目标文件的 **符号表(symbol table)** 中，符号表是一个结构数组，每个表项包含符号名、长度和位置信息等。

**重定位** 可重定位目标文件中的代码区和数据区都是从地址 0 开始的，链接去需要将不同的模块中相同的节合并起来生成一个新的单独的节，并将合并后的代码区和数据区按照操作系统确定的 **虚拟地址空间划分(也叫存储映像)** 来重新确定位置。

使用链接的好处：
+ 模块化，使一个程序被划分成多个模块，由不同的程序员进行编写，并且可以构建公共的函数库以提供经不同的程序进行重用。
+ 效率高，每个模块可以分开编译，修改时只需要重新编译修改过的源程序文件，然后重新链接。

# 2. 目标文件格式

## 2.1 目标代码(object code)

目标代码指编译器或汇编器处理源代码后所生成的机器语言目标代码。 **目标文件(object file)** 指存放目标代码的文件。

ELF(Executable and Linkable Format，可执行与可链接格式) 目标文件格式

目标文件中包含可以直接被 CPU 执行的机器代码以及代码在运行时使用的数据，还有其他的如重定位信息和调试信息。

目标文件格式既可以用于程序的链接，也可以用于程序的执行。

## 2.2 链接视图

链接视图主要由不同的节(section)组成，节是 ELF 文件中具有相同特征的最小可处理信息单位，不同的节描述了目标文件中不同类型的信息及其特征。

![ELF 链接视图](../images/ELF%20链接视图.png)

## 2.3 执行视图

执行视图主要有不同的段(segment)组成，描述了目标文件中的节如何映射到存储空间的段中，可以将多个节映射到同一个段。

![ELF 执行视图](../images/ELF%20执行视图.png)

## 2.4 程序头表

程序头表用来指示系统如何创建进程的存储器映像。用于创建进程存储器映像的可执行文件和共享库文件必须具有程序头表，而可重定位目标文件无需程序头表。

## 2.5 节头表

节头表包含文件中各节的说明信息，每个节在该表中都有一个与之对应的项，每一项都指定了节名和节大小之类的信息。用于连接的目标文件必须具有节头表。

# 3. 可重定位目标文件格式

可重定位目标文件主要包含代码部分和数据部分，它可以与其他可重定位目标文件链接，从而创建可执行目标文件、共享库文件或其他可重定位目标文件。

## 3.1 ELF 头

ELF 头位于目标文件的起始位置，包含文件结构说明信息，ELF 头的数据结构分 32 位系统对应结构和 64 位系统对应结构。

32 位系统对应的数据结构。

```c
#define EI_NIDENT     16

typedef struct {
    // e_ident 是一个长度为 16 字节的序列，最开始的 4 字节用来表示是否为 ELF 文件，
    // 第一个字节为 0x7F，后边三个分别是 'E'、'L'、'F'
    // 后边的 12 个字节中，包含一些标识信息，比如标识是 32 位还是 64 位，
    // 标识数据按照大端还是小端存放，表示 ELF 的版本等。
    unsigned char     e_ident[EI_NIDENT];
    // e_type 说明目标文件的类型，可重定位文件、可执行文件、共享库文件、还是其他类型的文件
    E1f32_Half        e_type;
    // e_machine 指定机器的结构类型，比如 IA-32、SPARC V9、AMD64 等
    E1f32_Half        e_machine;
    // e_version 表示目标文件的版本
    E1f32_Word        e_version;
    // e_entry 指定系统将控制权转移到的起始虚拟地址（入口点），如果文件没有关联的入口点，则为 0
    E1f32_Addr        e_entry;
    // e_phoff 
    E1f32_Off         e_phoff;
    // e_shoff 指出节头表在文件中的偏移量（以字节为单位）
    E1f32_Off         e_shoff;
    E1f32_Word        e_flags;
    // e_ehsize 用于说明 ELF 头的大小
    E1f32_Half        e_ehsize;
    // e_shentsize 表示节头表中一个表项的大小（以字节为单位），所有表项大小相同
    E1f32_Half        e_phentsize;
    E1f32_Half        e_phnum;
    E1f32_Half        e_shentsize;
    // e_shnum 表示节头表中的项数，和 e_phentsize 共同指定了节头表的大小。
    E1f32_Half        e_shnum;
    E1f32_Half        e_shstrndx;
} E1f32_Ehdr;
```

![ELF 可重定位目标文件](../images/ELF%20可重定位目标文件.png)

## 3.2 节头表

节头表由若干个表项组成，每个表项描述相应一个节的节名、位置和长度等信息，目标文件中的每个节都有一个表项与之对应。

## 3.3 节

节是 ELF 文件中的主体信息，包含了链接过程所用的目标代码信息，包括指令、数据、符号表和重定位信息等。一个典型的 ELF 可重定位目标文件包含下面几个节：
+ .text：目标代码部分。
+ .rodata：只读数据。
+ .data：已初始化的全局变量。
+ .bss：未初始化的全局变量。目标文件中区分已初始化和未初始化全局变量是为了提高空间利用率。
+ .symtab：符号表，在程序中被定义的函数名和全局变量名都属于符号，与这些符号相关的信息被保存在符号表中，每个可重定位目标文件都有一个 .symtab 节。
+ .rel.text：.text 节相关的可重定位信息。当链接器将某个目标文件和其他目标文件组合时，.text 节中的代码被合并后，一些指令中引用的操作数地址信息或跳转目标指令位置信息等都可能要修改。通常，调用外部函数或者引用全局变量的指令中的地址字段需要修改。
+ .rel.data：.data 节相关的可重定位信息。当链接器将某个目标文件和其他目标文件组合时，.data 节中的代码被合并后，一些全局变量的地址可能被修改。
+ .debug：调试用符号表，有些表项对程序中定义的局部变量和类型定义进行说明，有些表项对程序中定义和引用的全局变量进行说明。
+ .line：C 源程序中的行号和 .text 节中机器指令之间的映射。
+ .strtab：字符串表，包括 .symtab 节和 .debug 节中的符号以及节头表中的节名。字符串表就是以 null 结尾的字符串序列。

# 4. 可执行目标文件格式

可执行目标文件由链接器将由若干个相互关联的可重定位目标文件组合生成，可重定位文件中的代码和数据的地址是相对于起始地址 0 而得到的，而可执行文件中代码和数据的地址则按照操作系统规定的存储器映像来确定起始地址，并且可重定位文件中的代码和数据的地址将会被修改，使得它们被重定位到运行时的虚拟存储空间中相应地址处。

ELF 可执行目标文件由 ELF 头、程序头表、节头表以及夹在程序头表和节头表之间的各个不同的节组成。

![ELF 可执行目标文件](../images/ELF%20可执行目标文件.png)

+ .init：定义了一个 `_init` 函数，用于可执行目标文件开始执行时的初始化工作
+ 少了两个 .rel 节，因为可执行目标文件中的指令和数据已被重定位，所以可以去掉用于重定位的节
+ 程序头表，合称为段头表(segment header table)，是一个结构数组。可执行目标文件中所有代码的位置连续，所有只读数据的位置连续，所有可读可写数据的位置连续。所以这些连续的片段(chunk)被映射到存储空间（实际上是虚拟地址空间）中的一个存储段，程序头表用于描述这种映射关系，一个表项说明一个连续的片段或一个特殊的节。

32 位系统的程序头表中每个表项的数据结构：

```c
typedef struct {
    // p_type 描述存储段的类型或特殊节的类型。
    // 比如是否可以装入段(PT_LOAD)，是否是特殊的动态节(PT_DYNAMIC)，是否是特殊的解释程序节(PT_INTERP)
    E1f32_Word    p_type;
    // p_offset 指出本段的首字节在文件中的偏移地址
    E1f32_Off     p_offset;
    // p_vaddr 指出本段首字节的虚拟地址
    E1f32_Addr    p_vaddr;
    // p_paddr 指出本段首字节的物理地址，因为物理地址由操作系统根据情况动态决定，因而该信息通常是无效的
    E1f32_Addr    p_paddr;
    // p_filesz 指出本段在文件中所占的字节数，可以是 0
    E1f32_Word    p_filesz;
    // p_memsz 指出本段在存储器中所占字节数，可以是 0
    E1f32_Word    p_memsz;
    // p_flags 指出存取权限
    E1f32_Word    p_flags;
    // p_align 指出对齐方式，有一个模数表示，为 2 的正整数幂，
    // 通常模数与页面大小相关，若页面大小为 4KB，则模数为 2 的 12 次方
    E1f32_Word    p_align;
} E1f32_Phdr;
```

# 5. 符号表和符号解析

## 5.1 符号与符号表

链接器在生成一个可执行目标文件时，必须完成符号解析，而要进行符号解析，则需要用到符号表，通常目标文件中都有一个符号表，表中控包含了在程序模块中被定义的所有符号的相关信息。对于某个 C 程序模块 m 来说，包含在符号表中的符号有以下三种不同类型。

+ 在模块 m 中定义并被其他模块引用的 **全局符号(global symbol)** ，这类符号包括非静态的函数名和被定义为不带 static 属性的全局变量名。
+ 由其他模块定义并被 m 引用的 **外部符号(external symbol)** ，包括在其他模块定义的外部函数名和外部变量名。
+ 在模块 m 中定义并在 m 中引用的 **本地符号(local symbol)** ，这类符号包括带 static 属性的函数名和全局变量名。这类在一个过程（函数）内部定义的带 static 属性的本地变量不在栈中遍历，而是被分配在静态数据区，即编译器为他们在节 .data 或 .bss 中分配空间。如果模块 m 内有两个函数使用了同名 static 本地变量，则需要为这两个变量都分配空间，并作为两个不同的符号记录到符号表中。

ELF 文件中包含的符号表中每个表项具有以下数据结构：

```c
typedef struct {
    // st_name 给出符号在字符表中的索引（字节偏移量）
    // 指向在字符串表(.strtab节)中的一个以 null 结尾的字符串，即符号。
    E1f32_Word      st_name;  
    // st_value 给出符号的值，在可重定位目标文件中，值符号所在位置线相对于所在节起始位置的字节偏移量
    E1f32_Addr      st_value;  
    // st_size 给出符号所表示的对象的字节个数
    // 如果符号是函数名，则是指函数所占字节的个数。
    // 如果符号是变量，则是指变量所占字节的个数
    // 如果符号表示的内容没有大小或大小未知，则值为 0
    E1f32_Word      st_size;
    // st_info 指出符号的类型和绑定属性，参看下边的宏定义
    unsigned char   st_info;
    // st_other 指出符号可见性。通常在可重定位目标文件中执行可见性。
    // 它定义了当符号成为可执行目标文件或共享目标库的一部分后访问该符号的方式
    unsigned char   st_other;
    // st_shndx 指出符号所在的节的节头表中的索引
    E1f32_Half      st_shndx;
} E1f32_Sym;
```

**unsigned char   st_info;**  符号类型占低四位，符号绑定占高四位。

```c
#define ELF32_ST_BIND(info)          ((info) >> 4)
#define ELF32_ST_TYPE(info)          ((info) & 0xf)
#define ELF32_ST_INFO(bind, type)    (((bind) << 4) + ((type) & 0xf))
```

**符号类型** 可以是未指定(NOTYPE)、变量(OBJECT)、函数(FUNC)、节(SECTION)。当类型为 “节” 时，其表项主要用于重定位。

**绑定属性** 可以是本地(LOCAL)、全局(GLOBAL)、弱(WEAK)等。其中本地符号指在包含其定义的目标文件的外部是不可见的，名字相同的本地符号可存在于多个文件中而不会互相干扰。全局符号对于合并的所有目标文件都可见。弱符号与全局符号类似，但是其定义具有较低的优先级。

## 5.2 符号解析

符号解析的目的是将每个模块中引用的符号与某个目标模块中的定义符号建立关联。每个定义符号在代码段或数据段中都被分配了存储空间，因此，将引用符号与对应的定义符号建立关联后，就可以在重定位时将引用符号的地址重定位为相关联的定义符号的地址。

对于在一个模块中定义且在同一个模块中被引用的本地符号，链接器的符号解析会比较容易进行，因为编译器会检查买个模块中本地符号是否具有唯一的定义，所以，只要找到第一个本地定义符号与之关联即可。对于跨模块的全局符号解析，则比较困难。

编译器在对源程序编译时，会把每个全局符号输出到汇编代码文件中，每个全局符号或者是强符号或者是弱符号。汇编器把全局符号的强、弱特性隐含地编码在可重定位目标文件的符号中，以供链接时符号解析所用。

### 5.2.1 全局符号的强、弱特性

+ **强符号** ：函数名和已初始化的全局变量名。
+ **弱符号** ：未初始化的全局变量。

链接器根据强弱符号的处理规则来处理 **多重定义符号**：
+ 规则 1 ：强符号不能多次定义，否则链接出错。
+ 规则 2 ：弱一个符号被说明为一次强符号和多次弱符号定义，则按照强符号定义为准。
+ 规则 3 ：若有多个弱符号定义，则任选其中一个。

尽量避免使用全局变量，一定要使用的话，就把全局变量定义为 static，这样没有强弱之分，而且不会和其他全局符号产生冲突，如果其他模块需要引用它，就将它封装成函数。此外，尽量要给全局变量赋初始值使其变成强符号，而外部全局变量则尽量使用 extern。

### 5.2.2 符号解析过程

编译系统通常会提供一种将多个目标模块打包成一个单独的库文件的机制，这个库文件就是 **静态库(static library)** ，在构建可执行文件时只需要指定库文件名，链接器会自动到库中寻找那些应用程序用到的目标模块，并且只把用到的模块从库中拷贝出来。

程序中的符号包含变量名和函数名，它们在程序之后可能出现在定义处，称为 **符号的定义** ，也可能出现在引用处，称为 **符号的引用** 。

# 6. 与静态库的链接

在类 UNIX 系统中，静态库文件采用一种称为 **存档档案(archive)** 的特殊文件格式，使用 .a 后缀。

自定义静态库文件的流程。

假设现在有源文件 m1.c 和 m2.c。

```c
// m1.c
#include <stdio.h>

void m1Func() {
  printf("%s", "This is m1Func from mylib\n");
}

// m2.c
#include <stdio.h>

void m2Func() {
  printf("%s", "This is m2Func from mylib\n");
}
```

使用 AR 工具生成静态库，先使用 `gcc -c` 命令将静态库中包含的目标模块先生成可重定位目标文件。

在命令行分别执行 `gcc -c m1.c` 和 `gcc -c m2.c` 命令，分别生成 m1.o 和 m2.o 文件。

在命令行输入 `ar rcs mylib.a m1.o m2.o` 生成静态链接库 `mylib.a` 文件

现在有 main.c 文件，调用了静态库 mylib.a 的 m1Func 函数。

```c
void m1Func(void);

int main() {
  m1Func();
  return 0;
}
```

为了生成可执行文件 main.exe，可以先将 main.c 编译并汇编为可重定位目标文件 main.o，然后再将 main.o 和 mylib.a 以及标准 C 函数库 libc.a 进行链接。

在命令行输入 `gcc -c main.c` 生成可重定位目标文件 main.o。

在命令行输入 `gcc -static -o main main.o ./mylib.a` 生成可执行文件 main.exe。

命令中使用 `-static` 选项指示链接器生成一个完全链接的可执行文件，即生成的可执行文件应能直接加载到存储器执行，而不需要在加载或运行时再动态链接其他目标模块。


# 7. 重定位

重定位的目的是在符号解析的基础上将所有关联的目标模块合并，并确定运行时每个定义符号在虚拟地址空间中的地址，在定义符号的引用处重定位引用的地址。

+ 节和定义符号的重定位：链接器将素有模块中相同类型的节合并，生成一个同一类型的新节。
+ 引用符号的重定位：链接器对合并后新代码节(.text)和新数据节(.data)中的引用符号进行重定位，使其指向对应的定义符号起始处。

# 8. 可执行文件的加载

当启动一个可执行目标文件执行时，首先会通过某种方式调出常驻内存的一个称为 **加载器(loader)** 的操作系统程序来进行处理。
