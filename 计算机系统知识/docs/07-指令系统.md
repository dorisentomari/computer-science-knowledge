计算机系统可以分为 4 个层次，分别为应用软件、基础软件、硬件逻辑和物理载体。

软件以指令形式运行在 CPU 硬件上，而指令系统介于软件和硬件之间，是软硬件交互的界面，有着非常关键的技术。

软硬件本身的更新迭代速度很快，而指令系统则可以保持较长时间的稳定。

# 1. 指令系统

## 1.1 指令系统设计原则

+ 指令系统设计原则：兼容性、通用性、高效性、安全性
+ 影响指令系统的因素：工艺技术、计算机体系结构、操作系统、编译技术、应用程序

## 1.2 指令系统发展历程

### 1.2.1 指令集的分类
+ 复杂指令集(CISC，Complex Instruction Set Computer)
    + 早期采用 CISC，处理器设备昂贵，速度慢，加入大量的复杂指令提高执行速度
    + 简化了软件和编译器的设计
    + 提高了硬件的复杂性
    + 大量的指令实际很少使用，消耗大量精力的复杂设计只有很少的回报
    + 复杂的微代码翻译增加流水线设计难度，降低频繁使用的简单指令的执行效率
+ 精简指令集(RISC，Reduced Instruction Set Computer)
    + 单个指令执行周期短
    + 使用定长指令，译码简单
    + 访存只能通过 load-store 指令实现
    + 实现高效的流水线，多发射等技术，提高主频和效率
+ 超长指令字(VLIW，Very Long Instruction Word)
    + 最大程度利用指令级并行
    + 一个超长指令字由多个互相不存在相关性的指令组成，可并行进行处理
    + 简化硬件实现，但是增加编译器的设计难度

### 1.2.2 存储管理的演变
+ 连续实地址：各程序所需的内存空间必须连续存放，并保证不与其他程序产生冲突。会造成内存碎片，难以管理多个程序。
+ 段式存储管理：将内存分为多个段和节，地址组织为相对于段地址的偏移。
+ 页式虚拟存储管理：将各进程的虚拟内存空间划分为若干长度相同的页，将虚拟地址和物理地址的对应关系组织为页表，并同经过硬件来实现快速地址转换。

### 1.2.3 运行级别的演变
+ 无管理
+ 增加保护模式：现代操作系统包含保护模式，将程序分为两个权限等级，用户态和核心态。
+ 增加调试模式：ARM 的 JTAG，MIPS 的 EJTAG
+ 增加虚拟支持：服务器领域虚拟化
+ 以 MIPS 处理器为例
    + 调试模式
    + 根模式
    + 客户模式

## 1.3 指令集结构

### 1.3.1 不同类型指令系统
+ 堆栈型：又称为零地址指令，操作数都在栈顶，在运算指令中不需要指定操作数，默认对栈顶数据进行运算并将结果压回栈顶。
+ 累加器型：又称为单地址指令，包含一个隐含操作数——累加器，另一个操作数在指令中指定，结果写会到累加器中。
+ 寄存器 - 存储器型：每个操作数都由指令显示指定，操作数为寄存器或内存地址。
+ 寄存器 - 寄存器型：
    + 所有访存都必须显式通过 load 和 store 指令来完成，又称为 load-store 型
    + 寄存器之间的相关性容易判断，容易实现流水线、多发射、乱序执行等

使用寄存器的优势，访问速度快，便于编译器的调度优化，充分利用局部性原理，大量操作可以在寄存器内完成。

### 1.3.2 操作数
+ 数据类型：char、short、int、long、long long
+ 访存地址：对齐问题和尾端问题
    + 对齐访问是指对该数据的访问起始地址和结束地址都符合其数据长度，如果只支持对齐访问，则缺少灵活性。如果不支持对齐访问，则增加复杂度。
    + 尾端问题：不同机器采用不同的尾端方式，带来数据兼容问题，最高有效字节的地址较小的是大尾端，最低有效字节的地址较小的是小尾端。
+ 寻址方式：偏移量寻址、立即数寻址和寄存器间接寻址是最常用的寻址方式，而集训期间接寻址相当于偏移量为 0 的偏移量寻址。

### 1.3.3 操作指令和编码
+ 指令分类(功能上分类)：
    + 运算指令
    + 访存指令
    + 转移指令
    + 特殊指令
+ 指令编码：操作数和操作码在整个指令码中的摆放方式
    + CISC 指令系统的指令码长度可变，依据类似赫夫曼(Huffman)编码的方式将操作码的平均长度缩小
    + RISC 指令系统的指令码长度固定，需要合理定义来保证各指令码能存放所需要的操作码、寄存器号、立即数等。

## 1.4 RISC 指令集比较

### 1.4.1 指令格式比较

在寄存器类指令中，操作码都有操作码(OP)和辅助操作码(OPX)组成，操作数都包含两个源操作数(RS)和一个目标操作数(RD)。立即数指令都由操作码、源操作数、目标操作数和立即数(const)组成，立即数的位数各有不同，跳转类指令大同小异，PA-RISC 与其他三种差别较大。

### 1.4.2 公共指令功能
+ load-store 指令，load-store 对通用寄存器进行存取操作。
+ ALU 指令，ALU 指令都是寄存器类型的，常见的 ALU 指令包括 加、减、乘、除、与、或、异或、移位、比较等
+ 控制流指令，控制流指令分为绝对跳转指令和相对跳转指令，相对跳转指令的目标地址是当前的 PC 值加上指令中的偏移量立即数，绝对跳转的目标地址直接由寄存器或指令中的立即数给出。

# 2. 特权指令系统

每一个应用程序都有自己的寄存器、内存管理以及可执行的指令。现代计算机的指令系统在用户态子集之外还定义了特权态部分，称之为特权指令系统。

不同指令系统的特权态部分差别较大，但是就其机制而言，主要分为以下几类：
+ 运行模式定义及转换
+ 虚拟存储管理
+ 异常与中断处理
+ 控制寄存器

## 2.1 异常与中断

### 2.1.1 异常分类
+ 外部事件
+ 指令执行中的错误
+ 数据完整性问题
+ 地址转换异常
+ 系统调用和陷入
+ 需要软件修正的运算

### 2.1.2 异常处理
+ 异常处理准备
+ 确定异常来源
+ 保存执行状态
+ 处理异常
+ 恢复执行状态并返回

### 2.1.3 中断
+ 中断的优先级和原子性
+ 向量化中断
+ 中断传递机制

## 2.2 存储管理

+ 原理：存储管理构建虚拟的内存地址，并通过存储管理部件(Memory Management Unit，MMU) 进行虚拟地址到物理地址的转换。

+ 作用和意义：
    + 隐藏和保护
    + 为程序分配连续的内存空间
    + 扩展地址空间
    + 节约物理内存

# 3. 软硬件协同

## 3.1 函数调用规范

ABI(Application Binary Interface) 应用程序二进制接口

ABI 通常会包含寄存器使用、函数调用、数据表示格式等约定。

MIPS 指令系统流行的 ABI 主要有三种

+ O32，传统的 MIPS 约定，广泛应用于嵌入式工具链和 32 位 Linux 中
+ N64，在 64 位处理器中使用新的正式 ABI，改变指针和 long 的宽度，并改变了寄存器使用的约定和参数传递的方式
+ N32，在 64 位处理器上执行的 32 位程序，与 N64 的区别在于指针和 long 的宽度

### 3.1.1 MIPS 堆栈布局

依据函数是否调用其他函数，可以将函数分为叶子函数和非叶子函数：

+ 叶子函数，简单堆栈函数，无须费力构造堆栈布局
+ 非叶子函数，包含其他函数调用的函数，开始时需要设置 sp 寄存器，为自己的函数分配空间并标明嵌套调用的参数结构基址
+ 复杂堆栈结构

## 3.2 系统调用过程
+ Linux 操作系统部分系统调用
    + 进程控制
    + 文件读写
    + 文件系统
    + 系统控制
    + 内存管理
    + 信号量

## 3.3 同步与通信

当线程之间出现资源访问的冲突时，需要有同步和通过新的机制来保证并发数据访问的正确性

### 3.3.1 基于互斥的同步机制

为了使得更复杂的操作具有原子性，Linux 使用锁机制，锁是对信号量机制的一种简单实现。

访问同一数据的软件都要互相协助，同一时刻只能有一个线程可以操作该数据，任何访问被锁住数据的线程将被阻塞。

### 3.3.2 非阻塞的同步机制

+ 基于锁的资源保护和线程同步的缺点
    + 若持有锁线程死亡、阻塞或死循环，其他等待锁的线程将可能永远等待下去
    + 锁机制中获取和释放锁有代码
    + 锁导致的错误与时机油管，难以重现
+ 事务内存 Transactional Memory

通过尝试性执行事务代码，在程序运行过程中动态检测事务间的冲突，并根据冲突检测结果进行提交或取消事务。

# 4. 指令流水线

## 4.1 单周期处理器

指令系统按照功能可以分为运算指令、访存指令、转移指令和特殊指令四类。

根据指令集的定义，可以得知 CPU 的数据通路包含以下组成要素：

+ 程序计数器，又称 PC，指示当前指令的地址
+ 指令存储器，按照指令地址存储指令码，接受 PC ，读出指令
+ 译码部件，用于分析指令，判断指令类别
+ 通用寄存器堆，用于承载寄存器的值，绝大多数指令都需要读取及修改寄存器。
+ 运算器，用于执行指令所指示的运算操作
+ 数据存储器，按照地址存储数据，主要用于访存指令

数据通路上各组成要素的具体连接规则：

+ 根据 PC 从指令存储器种取出指令，然后是译码部件解析出相关控制信号，并读取通用寄存器堆。
+ 运算器堆对通用寄存器堆独处的操作数进行计算，得到计算指令的结果写回通用寄存器堆，或者得到访存指令的地址，或者得到转移指令的跳转目标。
+ load 指令访问数据存储器后，需要将结果写回通用寄存器堆。
+ 通用寄存器堆写入数据在计算结果和访存结果之间二选一。
+ 由于有了控制流指令的存在，因此新指令的 PC 既可能等于顺序下一体指令的 PC，也可能来自转移指令计算出的跳转目标。

译码部件要识别不同的指令，并根据指令要求，控制读取那些通用寄存器，执行何种运算，是否要读写数据存储器，写哪个通用寄存器，以及根据控制流指令来决定 PC 的更新。

## 4.2 流水线处理器

每个之中周期必须完成取指，译码，读存储器，执行，访存等多个工作，为了保证下一个时钟上升沿到来之前准备好寄存器堆的写数据，所以每个时钟周期的间隔就要很长，导致处理器的主频无法提高。

使用流水线技术可以提高处理器的主频。

如果在每段操作前后加上触发器，采用分频时钟的处理器模型称为多周期处理器。多周期处理器设计可以提高运行频率，但是每条指令的执行时间并不能降低。

但是我们可以将各个执行阶段以流水方式组织起来，同一时刻不同指令的不同执行阶段重叠在一起，进一步提高 CPU 执行效率。

多周期处理器演进到流水线处理器，核心在于控制逻辑和数据通路对应关系维护机制的变化。

## 4.3 指令相关和流水线冲突

指令间的相关可以分为三类：数据相关、控制相关、结构相关。

在程序中，如果两条指令访问同一个寄存器或内存单元，而且这两条指令中至少有一条是写该寄存器或内存单元的指令，那么这两条指令之间就存在数据相关。

如果两条指令中一条是转移指令， 而且另外一条是否被执行取决于该转移指令的执行结果，则这两条指令就存在控制相关。

如果两条指令使用同一份硬件资源，则这两条指令存在结构相关。

## 4.4 流水线与异常处理

异常可以分为可恢复异常和不可恢复异常。

不可恢复异常通常发生在系统硬件出现了严重故障的时候，此时异常处理后系统通常面临重启，所以处理器响应不可恢复异常的机制很简单，只要立即终止当前的执行，记录软件所需要的信息然后跳转到异常处理入口即可。

可恢复异常处理比较难，要求做的非常精确，精确异常要求处理完毕异常之后，回到产生异常的地方接着执行，还能执行正确，就好像是没有发生过异常一样。要达到整个效果，要求在处理异常时，发生异常的指令前面的所有指令都必须执行完毕，而发生异常的指令及其后面的指令都没有执行。

## 4.5 提高流水线效率的技术

流水线 CPI = 理想 CPI + 结构相关阻塞周期数 + RAW 阻塞周期数 + WAR 阻塞周期数 + WAW 阻塞周期数 + 控制相关阻塞周期数

### 4.5.1 多路发射技术

让处理器中每一级流水线都可以同时处理更多的指令，这被称为多发射数据通路技术。

要在处理器中支持多发射，首先就要将处理器中的各种资源翻倍，包括采用支持双端口的存储器。其次还要增加额外的阻塞判断逻辑，当同一个时钟周期执行的两条指令存在执行相关，也需要进行阻塞。包括数据相关、控制相关和结构相关在内的阻塞机制修需要略微改动。

多发射数据通路技术理论上可以大幅降低处理器的 CPI，但是由于各类相关所引起的阻塞影响，实际执行效率是要打折扣的。

### 4.5.2 动态调度

把相关的解决尽量往后拖延，同时前面指令的等待不影响后面指令继续进行。

ROB(Re-order Buffer，重排序缓存)

实现动态调整后流水线各阶段的调整：

+ 取指，不变。
+ 译码，拆分为译码和发射两个阶段
+ 发射，把操作队列的指令根据操作类型送到保留站，并在 ROB 种指定一项作为临时保存该指令结果调用。
+ 指令，如果所需要的操作数都准备好，则执行。否则根据结果 ROB 号侦听结果总线并接收结果总线的值。
+ 写回，把结果送到结果总线，释放保留站，ROB 根据结果结果总线修改相应的项。
+ 提交，如果队列种的第一条指令的结果已经写回并且没有发生异常，把该指令的结果从 ROB 写回到寄存器或存储器，释放 ROB 的相应项。如果队列头的指令发生了异常或者转移指令猜测错误，清除操作队列以及 ROB。

### 4.5.3 转移预测

在转移指令的取指或译码阶段预测出转移指令的方向和目标地址，并从预测的目标地址继续取指令执行。

猜测正确，就不会阻塞流水线。

硬件转移预测有两个步骤：
    + 预测，取指或译码阶段预测转移指令是否跳转以及转移的目标地址，并根据预测结果进行后续指令的取指。
    + 确认，转移指令执行完毕后，比较最终确定的转移条件和转移目标与之前预测的结果是否相同，如果不同则需要取消预测后的指令执行，并从正确的目标重新开始执行。
