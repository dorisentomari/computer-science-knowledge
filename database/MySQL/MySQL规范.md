# 1. 数据库设计规范
+ 所有数据库对象名称必须使用小写字母并用下划线分割（MySQL对大小写敏感）
+ 所有数据库对象名称禁止使用 MySQL 保留关键字（比如 from 字段）
+ 所有数据库对象命名要做到见名识意，并且最好不超过 32 个字符
+ 所有临时数据表必须使用 tmp 为前缀，并且以日期为后缀
+ 所有备份库，备份表必须以 bak 为前缀，并且以日期为后缀
+ 所有存储相通数据的列名和列类型必须一致

# 2. 数据表设计规范
+ 所有数据表都必须使用 InnoDB 作为存储引擎
+ 数据库和表的字符集统一使用 UTF8
+ 所有的表和字段都必须添加注释
+ 尽量控制单表数据量的大小，建议控制在 500 万行以内（历史数据归档，分库分表等方法）
+ 谨慎使用 MySQL 分区表（跨分区查询效率可能更低，使用物理分表方式管理大数据）
+ 尽量做到冷热分离，减少表的宽度（减少磁盘 IO，保证热数据的内存缓存命中率。利用更有效的缓存，避免读入无效数据）
+ 禁止在表中建立预留字段（预留字段很难做到见名识意，无法确认存储的数据类型，对预留字段类型修改，会锁表）
+ 禁止在数据库中存储图片，文件等二进制数据
+ 禁止在线上做数据库压力测试
+ 禁止从开发环境、测试环境直接连接生产环境

# 3. 索引设计规范
+ 限制每张表上的索引数量，建议每张表索引不超过 5 个
    + 增加查询效率，但是会降低插入和更新效率
    + 禁止给表中的每一列都建立单独的索引
+ 每个 InnoDB 表必须有一个主键
    + 不能使用更新频繁的列作为主键，不使用多列主键
    + 不要使用 uuid，MD5，HASH，字符串列作为主键
    + 建议使用自增 ID
+ 注意合理选择符合做主键值的顺序
    + 在 SELECT, UPDATE, DELETE 语句的 WHERE 从句中的列，包含在 ORDER BY，GROUP BY，DISTINCT 中的字段
    + 多表 JOIN 的关联列
+ 区分度最高的列放在联合索引的最左侧，尽量把字段长度小的放在联合索引左侧
+ 避免建立冗余索引和重复索引
+ 对于频繁的查询优先考虑使用覆盖字段
    + 避免 InnoDB 表进行索引的二次查找
    + 可以把随机 IO 变为顺序 IO 加快查询效率
+ 尽量避免使用外键
    + 不建议使用外键约束
    + 外键可用于保证数据的参照完整性，但是建议在业务中实现
    + 外键会影响父表和子表的写操作从而影响性能

# 4. 数据库字段设计规范
+ 优先选择符合存储需要的最小的数据类型
    + 对于非负数数据采用无符号整型进行存储（无符号数据比有符号多一倍的存储空间）
    + VARCHAR(N) 中的 N 代表的是字符数，不是字节数，使用 UTF8 存储汉字 VARCHAR(255) = 255 个汉字 = 765 个字节
    + 过长的长度会消耗更多的内存
+ 避免使用 TEXT，BLOB 数据类型
    + 建议把 BLOB 或者 TEXT 列分离到单独的扩展表
    + BLOB 或者 TEXT 类型只能使用前缀索引
+ 避免使用 ENUM 类型
    + 修改 ENUM 值需要使用 ALTER 语句（容易造成操作失误，引起操作锁）
    + ENUM 类型的 ORDER BY 操作效率低，需要额外操作
    + 禁止使用数值作为 ENUM 的枚举值
+ 尽可能把所有列定义为 NOT NULL
    + 索引 NULL 列需要额外的空间来保存，所以要占用更多的空间
    + 进行比较和计算时要对 NULL 做特殊处理
+ 使用 TIMESTAMP 或者 DATETIME 类型存储时间
    + 无法用日期函数进行计算和比较
    + 用字符串存储日期要占用更多的空间
+ 财务相关的金额类数据，必须使用 decimal 类型
    + decimal 类型为精准浮点数，在计算式不会丢失精度
    + 占用空间由定义的宽度决定
    + 可用于存储比 bigint 更大的整数数据

# 5. SQL 开发规范
+ 建议使用预编译语句进行数据库操作
    + 预编译，一次解析 SQL 语句，多次使用，提高处理效率
    + 只传递参数，减少带宽，比传递 SQL 语句更加高效
    + 有效避免 SQL 注入风险
+ 避免数据类型的隐式转换
    + 隐式转换会导致索引失效
+ 充分利用表上已经存在的索引
    + 避免使用双 % 号的查询条件。比如 `a LIKE '%123%';`
    + 一个 SQL 只能利用到复合索引中的一列进行范围查询
    + 使用 LEFT JOIN 或 NOT EXISTS 来优化 NOT IN 操作
+ 程序连接不同的数据库使用不同的账号，禁止跨库查询
    + 考虑数据库未来的扩展
    + 为数据库迁移和分库分表留出余地
    + 降低业务耦合度
    + 避免权限过大而产生的安全风险
+ 禁止使用 `SELECT *`，必须使用`SELECT <字段列表>` 查询
    + 消耗更多的 CPU 和 IO 以及网络带宽资源
    + 无法使用覆盖索引
    + 可减少表结构的变更带来的影响
+ 禁止使用不含有字段列的 INSERT 语句。比如 `INSERT INTO T VALUES(1, 2, 3);`。正确用法：`INSERT INTO T(t1, t2, t3) VALUES(1, 2, 3);`
+ 禁止使用子查询，可以把子查询优化为 JOIN 操作
    + 子查询结果无法使用索引
    + 子查询会产生临时表操作，如果子查询数据量大，则严重影响效率
    + 效果过多的 CPU 及 IO 资源
+ 禁止使用 JOIN 关联太多的表
    + 每 JOIN 一个表会多占用一部分内存(join_buffer_size)
    + 会产生临时表操作，影响查询效率
    + MySQL 最多允许关联 61 个表，建议不超过 5 个
+ 减少同数据库的交互次数。比如 分页时可一次取 100 条数据，但是分多次显示，不要每次取 1 条，分 100 次取
    + 数据库更适合处理批量操作
    + 合并多个相同的操作到一起，可以提高处理效率
+ 使用 in 代替 or
    + in 的值不要超过 500 个
    + in 操作可以有效的利用索引
+ 禁止使用 ORDER BY RAND() 进行随机排序
    + 会把表中所有符合条件的数据装载到内存中进行排序
    + 会消耗大量的 CPU 和 IO 及内存资源
    + 推荐在过程中获取一个随机值，然后从数据库中获取数据的方式
+ WHERE 从句中禁止对列进行函数转换和计算
    + 对列进行函数转换或计算会导致无法使用索引
+ 在明显不会有重复值的时候，使用 UNION ALL 而不是 UNION
    + UNION 会把所有数据放到临时表后再进行去重操作
    + UNION ALL 不会再对结果集进行去重操作
+ 拆分复杂的大 SQL 为多个小 SQL
    + MySQL 一个 SQL 只能使用一个 CPU 进行计算
    + SQL 拆分后可通过并行查询来提交效率

# 6. 数据库操作行为规范
+ 超过 100 万行的批量写操作，要分批多次进行操作
    + 大批量的操作可能会造成严重的主从延迟
    + binlog 格式为 row 格式时会产生大量的日志
    + 避免产生大事务操作
+ 对大表使用 pt-online-schema-change 修改表结构
    + 对大表结构的修改要严谨操作，会造成长时间的锁
    + pt-online-schema-change 原理是先把原数据表的数据复制到一个新表里，然后在老表里添加触发器，最后以极快的速度把旧表删除，把新表命名为旧表的名字
    + 避免大表修改产生的主从延迟
    + 避免在对表字段进行修改时进行锁表
+ 禁止为程序使用的账号赋予 super 权限
    + 当打到最大连接数限制时，还允许 1 个有 super 权限的用户连接
    + super 权限只能留给 DBA 处理问题的账号使用
+ 对于程序连接数据库账号，遵循权限最小原则
    + 程序使用的数据库账号只能在一个 DB 下使用，不准跨库
    + 程序是哟经的账号原则上不允许有 drop 权限
