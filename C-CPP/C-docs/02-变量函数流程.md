# 1. 数据类型
+ 基本类型
  + 整型 int short long
  + 字符型 char
  + 实型(浮点型)
    + 单精度实型 float
    + 双精度实型 double
+ 构造类型
  + 数组类型
  + 结构类型 struct
  + 联合类型 union
  + 枚举类型 enum
+ 指针类型 char *, int *, int ** 等

# 2. extern 关键字
+ 声明一个变量，但是变量没有建立存储空间
+ 没有存储空间，就不能赋值

```c
// 声明并赋值
int a = 5;

// 声明，但是没有内存空间
extern int c;
```

# 3. 预处理
+ `#` 开头的语句是预处理语句，无需分号结束
+ 宏定义以后的代码都可以直接使用

# 4. 进制
+ 数据在计算机中主要是以补码的形式存储的
+ 进制赋值与显示

```c
// 十进制赋值
int a = 12;
// 八进制赋值
int b = 01234567;
// 十六进制赋值
int c = 0xa1;
// 十进制显示
printf("%d\n", a);
// 八进制显示
printf("%o\n", a);
// 十六进制
printf("%x\n", a);
```

+ 原码：原始的二进制数据

```
+1: 0000 0001
-1: 1000 0001
+0: 0000 0000
-0: 1000 0000
```

+ 反码：符号位不变，其他位全部取反。正数的原码、反码和补码是它自身的值。

```
+1: 0000 0001
-1: 1111 1110
+0: 0000 0000
-0: 1111 1111
```

+ 补码：正数的补码是它自身的值，负数的补码等于它的反码 + 1

由于一个 byte 等于 8 个字节，但是 -0 的补码为 9 个字节，所以就舍弃最高位，所以 -0 的值等于 0

+ 十进制是站在原码角度来计算，二进制，八进制和十六进制是站在补码角度来计算，所以是不一样的。

```
+1:   0000 0001
-1:   1111 1111
+0:   0000 0000
-0: 1 0000 0000
```

```
// 例子 1
int a = 0x81;
// 得到的结果是 -127
// 解析原因如下
// 二进制：1000 0001，最高位是 1，所以他是负数
// 补码：1000 0001
// 反码：1111 1110
// 原码：1111 1111
// 原码 1111 1111 的十进制的值为 -127

---------------------
// 例子 2
int a = 0xe5;
// 二进制：1110 0101，最高位是 1，所以他是负数
// 补码：1110 0101
// 反码：1001 1010
// 原码：1001 1011
// 原码 1001 1011 的十进制的值是 -27
```

# 5. 有符号和无符号
+ 有符号，最高位是符号位，如果是1代表负数，0代表正数
+ 无符号，最高位不是符号位，是数的一部分，无符号不可能是负数

```c
int b = 0x8000007b;
printf("%d\n", b); // -2147483525
printf("%u\n", b); // -2147483771
```

+ int 默认是有符号，所以 `signed int a = -10;` 等价于 `int a = -10;`
+ 无符号不能赋值为负数
+ %d 是有符号输出，%u 是无符号输出
+ 无符号的数字不能通过 %d 输出

# 6. char
+ 占一个字节
+ 无符号范围：0~255
+ 有符号范围：-128~127
+ 赋值或运算，不要越界

```c
char a = 127 + 2;
printf("%d", a); // -127
// 129
// 原码：1000 0001，这是一个负数
// 反码：1111 1110
// 补码：1111 1111，所以是 -127

---------------------------------
unsigned char b = 255 + 2;
printf("%u\n", b); // 1
```

# 7. sizeof
+ 运算符，功能是计算一个数据类型的大小，单位为字节

```c
printf("sizeof(char) = %u\n", sizeof(char));
printf("sizeof(short) = %u\n", sizeof(short));
printf("sizeof(int) = %u\n", sizeof(int));
unsigned short a = 9;
printf("sizeof(a) = %u\n", sizeof(a));
printf("a = %u\n", a);
```

# 8. 整型

## 8.1 输出
+ %d，输出一个有符号的 10 进制 int 型
+ %o，输出一个 10 进制 int 型
+ %x，输出一个 16 进制 int 型，字母小写
+ %X，输出一个 16 进制 int 型，字母大写
+ %u，输出一个 10 进制的无符号数
+ %hd，输出 short 类型
+ %d，输出 int 类型
+ %l，输出 long 类型
+ %ll，输出 long long 类型
+ %hu，输出 unsigned short 类型
+ %u，输出 unsigned int 类型
+ %lu，输出 unsigned long 类型
+ %llu，输出 unsigned long long 类型

## 8.2 所占字节
+ short 短整型，2 字节
+ int 整型，4 字节
+ long 长整型，windows 为 4 字节，Linux 为 4 字节(32位)，8 字节(64位)
+ long long 长长整型，8 字节

+ 注意
  + 整型数据在内存中所占的字节数与所选择的操作系统有关。C 语言标准没有明确规定整形数据的长度，但是 long 类型整数的长度不能短语 int 类型，short 类型整数的长度不能长于 int 类型
  + 当一个小的数据类型赋值给一个大的数据类型，不会出错，因为编译器会自动转化。但是当一个大的类型赋值给一个小的数据类型，那么就有可能会丢失高位

## 8.3 字符标识

|整型常量|所需类型|
|----|----|
|10|代表 int 类型|
|10l，10L|代表 long 类型|
|10ll，10LL|代表 long long 类型|
|10u，10U|代表 unsigned int 类型|
|10ul，10UL|代表 unsigned long 类型|
|10ull，10ULL|代表 unsigned long long 类型|

# 9. 字符类型
+ 一个数字，对应一个字符
+ 使用字符或者数字给字符变量赋值是完全等价的
+ 字符类型本质上就是 1 给字节大小的整型
+ 实际上就是说如果把一个 char 类型变量赋值为数字，那么这个变量默认会去 ascii 表里找这个数字对应的字符，如果这个数字不在 ascii 里，那么变量的值就是乱码
+ 字符原则上内部只有一个字符，但是转义字符不是，转义字符由反斜线组成的多个字符
+ 转义字符
  + `\n` 换行
  + `\b` 退格，删掉前一个字符
  + `\r` 光标切到句首，句首前边的字符都被覆盖掉了
  + `\0` 就是 0 

```c
char ch = 'a';
printf("ch = %c, ch = %d \n", ch, ch);
ch = 97;
printf("ch = %c\n", ch);
ch = '\b';
printf("abc%cdef\n", ch);
ch = '\r';
printf("abc%cdef", ch);
```

# 10. 浮点数
+ 数据精度不准确

```c
float a = 100.9f;
printf("%f\n", a);
printf("请输入 float: ");
scanf("%f", &a);
printf("%f\n", a);
```

# 11. 类型限定符
+ extern 声明一个变量，extern 声明的变量没有建立存储空间
+ const 定义一个常量，常量的值不能修改
+ volatile 防止编译器优化代码
+ register 定义寄存器变量，提高效率。register 是建议型的指令，而不是命令型的指令，如果 CPU 有空闲寄存器，那么 register 就生效，如果没有空闲寄存器，那么 register 就无效

# 12. 输入与输出
## 12.1 输入
+ 输入数字

```c
int a;
int b;
printf("请输入 a 和 b: ");
scanf("%d %d", &a, &b);
printf("a = %d, b = %d", a, b);
```
+ 输入字符

当用户通过 scanf 输入字符时，编译器会把输入内容先放在一块内存中(缓冲区)，scanf() 自动在缓冲区读取内容。加入第一次输入的是 a，那么输入 a 之后，按下回车，缓冲区得到的是 `a\n`，所以第二次 scanf 读取的时候，获取到的就是 `\n`，而不是新输入的内容。数字不会出现这种问题的原因是，缓冲区只会读取数字，非数字的全部忽略。所以可以通过一个中间字符把 `\n` 吃掉，这样再次输入的内容就进入到新的缓冲区了

```c
char a;
printf("请输入 a: ");
// scanf("%c", &a);
// 读取键盘的字符，放在 a 变量
a = getchar();
printf("a = %c\n", a);

char b;
// scanf("%c", &b);
b = getchar();

char c;
printf("请输入 c: ");
// scanf("%c", &c);
c = getchar();
printf("c = %c\n", c);
```

## 12.2 输出
```c
int a = 100;
printf("&a = %p\n", &a);
// 以 5 个字符填充，没有的字符填充空格，默认右对齐
printf("a1 = %5d\n", a);
// 以 5 个字符填充，没有的字符填充0，默认右对齐
printf("a2 = %05d\n", a);
// - 表示左对齐，注意 0 和 - 不能同时使用
printf("a3 = %-5d\n", a);
double b = 3.14;
// 默认小数点后边有 6 位
printf("b1 = %lf\n", b);
// 8 代表总长度为 8，3 代表小数点后边 3 位
printf("b2 = %8.3lf\n", b);
char ch = 'a';
// 直接输出内容
putchar(ch);
printf("\n");
```

# 13. 数字计算
+ 数字相除

```c
int a = 10;
int b = 2;
int c = a / b;
printf("c = %d\n", c);

double d = 1.0 / 2;
printf("d == %lf\n", d);

double e = 1 / 2.0;
printf("e == %lf\n", e);

double f = a * 1.0 / b;
printf("f == %lf\n", f);
```

+ 自增自减前置后置的区别

```c
// a++ 先用后加
int a1 = 1;
int b1 = 0;
b1 = a1++;
printf("a1 = %d, b1 = %d\n", a1, b1);

// ++a 先加后用
int a2 = 1;
int b2 = 0;
b2 = ++a2;
printf("a2 = %d, b2 = %d\n", a2, b2);

// a-- 先用后减
int a3 = 1;
int b3 = 0;
b3 = a3--;
printf("a3 = %d, b3 = %d\n", a3, b3);

// a-- 先减后用
int a4 = 1;
int b4 = 0;
b4 = --a4;
printf("a4 = %d, b4 = %d\n", a4, b4);
```

# 14. 运算符优先级
+ 优先级为 1
  + `[]` 数组下标
  + `()` 圆括号
  + `.` 成员选择(对象)
  + `->` 成员选择(指针)

+ 优先级为 2
  + `-` 负号运算符
  + `~` 按位取反运算符
  + `++` 自增运算符
  + `--` 自减运算符
  + `*` 取值运算符
  + `&` 取地址运算符
  + `!` 逻辑非运算符
  + `(类型)` 强制类型转换运算符
  + `sizeof` 长度运算符

+ 优先级为 3
  + `/` 除法
  + `*` 乘法
  + `%` 余数(取模)
  + `+` 加法

# 15. 类型转换
+ 强制类型转换原则，数据类型小的往数据类型大的转

# 16. 示例
+ 水仙花数

```c
#include <stdio.h>

int main() {
    int a, b, c, i;
    for (i = 0; i <= 999; i++) {
        a = i / 100;
        b = i % 100 / 10;
        c = i % 10;

        if (i == a * a * a + b * b * b + c * c * c) {
            printf("a = %d, b = %d, c = %d\n", a, b, c);
            printf("%d\n", i);
        }
    }
    return 0;
}
```
