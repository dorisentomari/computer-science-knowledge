交换文件说明

vim 写文件，如果没有保存就关闭，会自动生成一个后缀为 `.swp` 的隐藏交换文件，保存了前面写的内容

# 1. C 程序介绍

## 1.1 C 语言的版本

+ **K&R C**

在 1978 年，Kernighan 和 Ritchie 的《The C Programming Language》第一版出版,一直被广泛作为 C 语言事实上的规范,称 K&R C;

+ **ANSI C 和 ISO C**

1989年，C 语言被 ANSI 标准化,对 K&R C 进行了扩展,包括了一些新特性,也规定了一套标准函数库;

ISO 成立 WG14 工作组来规定国际标准的 C 语言,通过对 ANSI 标准的少量修改,最终通过了 ISO 9899:1990，随后 ISO 标准被 ANSI 采纳;

+ **C99**

在 ANSI 标准化后，WG14 小组继续致力于改进 C 语言，新的标准很快推出，就是 ISO9899:1999 (1999年出版)，这个版本就是通常提及的 C99，被 ANSI 于 2000 年三月采用;

+ **C11**

2011 年 12 月 8 日，ISO 正式公布 C 语言的新的国际标准草案: ISO/IEC1988:2001，即C11;

## 1.2 特别说明
+ **C语言规范定义得非常宽泛**

long型数据长度不短于int型

short型不长于int型

+ **导致的结果**

相同的程序在不同编译器上具有不同的解释结果

相同的程序在不同平台上运行结果不同

例如：整型变量定义、对 ++，-- 的解释、输入输出赋值顺序的不同、浮点数计算精度的不同

**但是，只要坚持使用标准形式，把程序从一个编译器移植到另一个编译器，就不会出现什么问题。**

## 1.3 程序设计语言的构成
+ 数据成分，用于描述程序中所设计的数据。有哪些数据类型？如何使用？
+ 运算成分，用于描述程序中所包含的运算。有哪些运算符号？如何使用？
+ 控制成分，用于描述程序中的控制构造。三种类型的控制语句是如何写的？
+ 传输成分，用于描述程序中数据的传输。在程序中如何输入和输出数据？

## 1.4 程序编译步骤

+ 预处理，宏定义展开、头文件展开、条件编译等，通过是将代码中的注释删除，这里并不会检查语法
+ 编译，检查语法，将预处理后文件编译成汇编文件
+ 汇编，将汇编文件生成目标二进制文件
+ 链接，C 语言写的程序时需要依赖各种库，所以编译之后还需要把库链接到最终的可执行程序中去

## 1.5 分步编译
+ 预处理: gcc -E hello.c -o hello.i
   + 就是把头文件，宏全部都 copy 到它所对应的位置
   + 宏的本质就是替换
+ 编译: gcc -S hello.c -o hello.s
+ 汇编: gcc -c hello.c -o hello.o
   + 生成目标文件，但是目标文件不能执行
+ 链接: gcc hello.c -o hello.out


## 1.6 gcc 
+ 参数
    + `-E` 只进行预处理
    + `-S` 只进行预处理和编译
    + `-c` 只进行预处理、编译和汇编
    + `-o <filename>` 执行生成的输出文件为 filename
+ 文件后缀
    + `.c` C 语言文件
    + `.i` 预处理器后的 C 语言文件
    + `.s` 编译后的汇编文件
    + `-o` 编译后的目标文件

## 1.7 编译器的任务

编译是将高级程序设计语言编写的源代码，转换成目标平台的机器语言代码的过程。

对于 C 语言或者其他语言，编译器的编译工作一般分为两个步骤，编译和链接。

编译是将源代码转换成目标代码的过程。目标代码文件不是一个完整的可执行文件，其中还缺少库代码和启动代码。

目标代码文件必须通过链接器将中间代码和其他运行库代码合并才能形成目标平台的可执行文件。

## 1.8 链接器的任务

通过编译器和链接器的分步编译，首先能够提高代码的可重用性和代码的可移植性。

其次，也能够提高编译效率。原有系统库代码可以不编译，部分无修改的代码也可以直接使用原有的目标文件，直接通过高效率的链接形成可执行文件。


# 2. CPU 内部结构与寄存器(了解)

## 2.1 存储器分类

+ **EDO DRAM(Extended Data Out DRAM)扩展数据输出动态存储器**

在把数据发送给 CPU 的同时去访问下一个页面，从而提高了工作效率(约比传统DRAM块15~30%)

+ **SDRAM(Synchronous DRAM)同步动态存储器**

工作在 CPU 外部总线的频率上，与 CPU 的时钟同步

+ **DDR(Double Data Rate SDRAM)双数据输出同步动态存储器**
    + DDR SDRAM 从理论上来讲,可以把 RAM 的速度提升一倍，它的时钟的上升沿和下降沿都可以读出数据
    + DDR2 电压 1.8v，高端频率可达到 1000MHz
    + DDR3 电压 1.5v，频率可到到 2000MHz，8bit 预读
    + DDR4 电压 1.2v，数据传输速率 3.2GT/s

+ 小节
    + 程序必须经过编译才能转换为 CPU 所能接受的指令
    + 一句程序有可能转换为多句指令
    + 在控制器的协调下连续，依次执行相应的指令
    + 程序执行过程在 **内存** 中完成的
    + 程序在执行过程中，在内存中的不同区域，存放代码和相关数据
    
## 2.2 64 位和 32 位的区别
+ 寄存器是 CPU 内部最基本的存储单元
+ CPU 对外是通过总线(地址、控制、数据)来和外部设计交互的，总线的宽度是 8 位，同时 CPU 的寄存器也是 8 位，那么这个 CPU 就叫 8 位 CPU
+ 如果总线是 32 位，寄存器也是 32 位，那么这个 CPU 就是 32 位
+ 有一种 CPU 内部的寄存器是 32 位，但总线是 16 位，准 32 位
+ 所有的 64 位 CPU 兼容 32 位指令，32 位要兼容 16 位的指令，所以在 64 位的 CPU 上是可以识别 32 位的指令
+ 在 64 位的 CPU 架构上运行 64 位的软件操作系统，那么这个系统是 64 位
+ 在 64 位的 CPU 架构上运行 32 位的软件操作系统，那么这个系统是 32 位
+ 64 位的软件不能运行在 32 位 CPU 上

## 2.3 寄存器、缓存和内存的关系

按照与 CPU 远近关系来看，离的最近的是寄存器，然后缓存(CPU缓存)，最后是内存。CPU 计算时，先预先把要用的数据从硬盘读取到内存，然后再把即将要用的数据读取到寄存器。于是 CPU <--> 寄存器 <--> 内存

如果总是操作内存的同一地址的数据，那么就会影响速度，于是就在寄存器与内存之间设置一个缓存。因为从缓存提取的速度远高于内存，但是缓存的价格高于内存，所以缓存相对就比较小

# 3. 关于 VS4996 错误
+ 由于微软在 VS2013 中不再建议使用 C 的传统库函数 scanf，strcpy, sprintf 等，所以直接使用这些库函数会导致 C4996 错误
+ 解决措施有两个，任何一个方法都行，最好把这两行写在文件顶部
  + 加宏 `#define _CRT_SECURE_NO_WARNINGS`
  + 加 pragma `#pragma warning(disable:4996)`

# 4. 负数补码的求法
+ signed int i = -123;
+ 先确定其符号位为 1
+ 糗事其绝对值的原码
+ 对原码的各个位取反
+ 对取反后的值 +1

# 5. 位运算

## 5.1  位运算
+ 用于对整数类型(int, char, long等)变量中的某一位 (bit) 或者若干位进行操作
+ 判断某一位是否为 1
+ 只改变其中的一位,而保持其他位都不变
+ **C/C++提供了六种位运算符来进行位运算操作**

## 5.2 `&` 按位与(双目)
+ 两个相同才为 1
+ 用途: 把某些位清零且保持其他位不变,也可以用来获取某变量中的某一位
	+ 把一个数的低位变成 0，n = n & 0xffffff00;， 如果 n 是 short 类型，可以直接 n &= 0xff00;
	+ 如何判断一个 int 型变量 n 的第 7 位是否是 1？只需看表达式 `n & 0x80` 的值是否等于 `0x80` 即可

```cpp
int main(int argc, char *argv[]) {
    int a = 0b1100100;
    int f = 0b0000;
    a = a & f;
    cout << "a: " << a << endl;
    return 0;
}
```

## 5.3 `|` 按位或(双目)
+ 有一个是 1 就为 1
+ 用途: 将某变量的某些位置 1 且保留其他位不变
	+ `n |= 0xff;`

```cpp
int main(int argc, char *argv[]) {
    int a = 0b1100100;						// a = 100;
    int f = 0x1111;
    a = a | f;
    cout << "a: "  << a << endl;	// 111
    return 0;
}
```

## 5.4 `^` 按位异或(双目)
+ 两个数不同为 1，相同为 0
+ 用途: 将某变量中的某些位取反,且保留其他位不变
	+ `n ^= 0xff;`
	+ `a ^ b = c; c ^ b = a; a ^ c = b` (穷举法可证,可以实现最简单的加密和解密)
	+ `int a = 5, b =7;`
	+ 实现 a 和 b 的值交换
    + a = a ^ b;
    + b = b ^ a;
    + a = a ^ b;

```cpp
int main(int argc, char *argv[]) {
    int a = 0b1100100;
    int f = 0xf;
    a = a ^ f;
    cout << "a: " << a << endl;
    return 0;
}
```

## 5.5 `~` 按位非(取反)(单目)
+ 0 变为 1，1 变为 0

## 5.6 `<<`左移(单目)
+ a << b
+ 将 a 各二进制全部左移 b 位即可
+ 左移 n 位,就等于是乘以 2 的 N 次方

## 5.7 `>>`右移(单目)
+ a >> b
+ 将 a 各二进制全部右移 b 位即可
+ 左移 n 位，就等于是除以 2 的 N 次方，除不尽的话，就往小里边取整
+ 如果原来的符号位为 1，右移时高位就补充为 1
+ 如果原来的符号位位 0，右移时高位就补充为 0

## 5.8 例题
+ 有两个 int 型的变量 a 和 n(0<=n<31)，要求写一个表达式，使得该表达式的值和a的第n位相同
+ (a>>n) & 1
+ (a & (1 << n)) >> n

# 6. tips
+ 如果需要换行且不用格式化输出的时候，可以使用 `puts` 来代替 `printf`，但是 `puts` 的实参只能有一个。
+ `%5d`，显示至少 5 位的十进制整数
+ `%5.1f`，显示至少 5 位的浮点数，但是小数点后只显示 1 位。
+ `%09.9f` 设置了 0 之后，如果数值前面有空余位置，那么用 0 来补齐位数。如果省略了 0，那么就用空白来补齐。
