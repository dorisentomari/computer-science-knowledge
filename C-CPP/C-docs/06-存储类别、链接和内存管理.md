# 1. 存储类别

## 1.1 作用域

函数作用域的范围是从形参定义处到原型声明结束。

变量的定义在函数的外面，具有文件作用域(file scope)。

**翻译单元和文件**

C 语言预处理实际上是用包含的头文件内容替换 `#include` 指令。所以编译器把源代码文件和所有的头文件都看成是一个包含信息的单独文件。这个文件被称为翻译单元(translation unit)。描述一个具有文件作用域的变量时，它的实际可见范围是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。

## 1.2 链接

C 变量有 3 种链接属性：外部链接、内部链接和无链接。

具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量。这意味着这些变量属于定义他们的块、函数或原型私有。

具有文件作用域的变量可以是外部链接或内部链接。外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用。

## 1.3 存储期

作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期。C 对象有 4 种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。

如果对象具有静态存储期，那么它在程序的执行期间一直存在。文件作用域变量具有静态存储期。对于文件作用域变量，关键字 static 表明了其链接属性，而非存储期。以 static 声明的文件作用域变量具有内部链接。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有静态存储期。

线程存储期用于并发程序设计，程序执行可以被分为多个线程。具有线程存储期的对象，从被声明时到线程结束一直存在。以关键字 `_Thread_local` 声明一个对象时，每个线程都获得该变量的私有备份。

块作用域的变量通常都具有自动存储期。当程序进入定义这些变量的块时，为这些变量分配内存；当退出整个块时，释放刚才为变量分配的内存。这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区。

变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的开始处到块的末尾。

## 1.4 5 种存储类别

|存储类别|存储期|作用域|链接|声明方式|
|---|---|---|---|---|
|自动|自动|块|无|块内|
|寄存器|自动|块|无|块内，使用关键字 register|
|静态外部存储期|静态|文件|外部|所有函数外|
|静态内部链接|静态|文件|内部|所有函数外，使用关键字 static|
|静态无链接|静态|块|无|块内，使用关键字 static|

## 1.5 自动变量

属于自动存储类别的变量具有自动存储期、块作用域且无链接。默认情况下，声明在块或函数头种的任何变量都属于自动存储类别。

关键字 auto 是存储类别说明符。auto 关键字在 C++ 中的用法完全不同，如果要编写兼容 C++ 的程序，最好不要使用 auto 作为存储类别说明符。

块作用域和无链接意味着只有变量定义所在的块中才能通过变量名访问该变量，也可以间接通过变量的值和地址作为另一个函数的参数。

## 1.6 寄存器变量

变量通常存储在计算机内存中。如果幸运的话，寄存器变量存储在 CPU 的寄存器中。与普通变量相比，访问和处理这些变量的速度更快。由于寄存器变量存储在寄存器而非内存中，所以无法获取寄存器变量的地址。绝大多数方面，寄存器变量和自动变量一样，都是块作用域、无链接和自动存储期。

使用存储类别说明符 register 便可以声明寄存变量。

## 1.7 块作用域的静态变量

静态变量像是一个不可变量。实际上，静态的意思是该变量在内存中原地不动，并不是说它的值不变。具有文件作用域的变量自动具有（也必须是）静态存储期。这些变量和自动存储类型一样，都相同的作用域，但是程序离开它们所在的函数之后，这些变量不会小时。也就是说，这种变量具有块作用域、无链接，但是具有静态存储期，计算机在多次函数调用之间会记录他们的值。在块中以存储类别说明符 static 声明这种变量。

## 1.8 外部链接的静态变量

外部链接的静态变量具有文件作用域、外部链接和静态存储期。该类别有时称为外部存储类别，属于该类别的变量称为外部变量。把变量的定义行声明放在所有函数的外面便创建了外部变量。为了指出该函数使用了外部变量，可以在函数中关键字 extern 再次声明。如果一个源代码文件中使用的外部变量定义在李刚一个源代码文件中，则必须使用 extern 在该文件中声明该变量。

## 1.9 内部链接的静态变量

该存储类别的变量具有静态存储期、文件作用域和内部链接。在所有函数外部用存储类别说明符 static 定义的变量具有这种存储类别。 


# 2. 分配内存: malloc 函数和 free 函数

**malloc 函数：申请内存**

malloc 函数接受一个参数，所需要的内存字节数。malloc 函数会找到合适的空闲内存块，这样的内存是匿名的。也就是说， malloc 分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。因此，可以把该地址赋给一个指针变量，并使用指针访问这块内存。因为 char 表示 1 字节，malloc 返回类型通常被定义为指向 char 的指针。

然而，从 ANSI C 开始，C 使用一个新的类型，指向 void 的指针。该类型相当于一个通用指针。malloc 函数可用于返回指向数组的指针、指向结构的指针，所以通常该函数的返回值会被强制转换为匹配的类型。在 ANSI C 中，应该坚持使用强制类型转换，提高代码的可读性。然而，把指向 void 的指针赋给任意类型的指针完全不用考虑类型匹配的问题。如果 malloc 分配的内存失败，将返回空指针。

```c
double *ptd;

ptd = (double *) malloc (30 * sizeof(double));
```

**free 函数：释放内存**

如果程序分配内存成功，便可以把 ptd 视为一个有 30 个 double 类型的值请求空间，并设置 ptd 指针指向该位置。

**calloc 函数：申请内存**

```c
long * newMemory;

newMemory = (long *) calloc (100, sizeof(long));
```

与 malloc 类似，calloc 也返回指向 char 的指针。在 ANSI C 之后，返回指向 void 的指针。如果要存储不同的类型，应该使用强制类型转换运算符。

calloc 函数接受两个无符号整数作为参数（ANSI C 规定是 size_t 类型）。第 1 个参数是所需要的存储单元数量，第 2 个参数是存储单元的大小（以字节为单位）。

free 函数也可以释放 calloc 分配的内存















