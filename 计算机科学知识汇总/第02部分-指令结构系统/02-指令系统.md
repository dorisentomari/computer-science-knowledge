计算机系统可以分为 4 个层次，分别为应用软件、基础软件、硬件逻辑和物理载体。

软件以指令形式运行在 CPU 硬件上，而指令系统介于软件和硬件之间，是软硬件交互的界面，有着非常关键的技术。

软硬件本身的更新迭代速度很快，而指令系统则可以保持较长时间的稳定。

# 1. 指令系统

## 1.1 指令系统设计原则

+ 指令系统设计原则：兼容性、通用性、高效性、安全性
+ 影响指令系统的因素：工艺技术、计算机体系结构、操作系统、编译技术、应用程序

## 1.2 指令系统发展历程

### 1.2.1 指令集的分类
+ 复杂指令集(CISC，Complex Instruction Set Computer)
    + 早期采用 CISC，处理器设备昂贵，速度慢，加入大量的复杂指令提高执行速度
    + 简化了软件和编译器的设计
    + 提高了硬件的复杂性
    + 大量的指令实际很少使用，消耗大量精力的复杂设计只有很少的回报
    + 复杂的微代码翻译增加流水线设计难度，降低频繁使用的简单指令的执行效率
+ 精简指令集(RISC，Reduced Instruction Set Computer)
    + 单个指令执行周期短
    + 使用定长指令，译码简单
    + 访存只能通过 load-store 指令实现
    + 实现高效的流水线，多发射等技术，提高主频和效率
+ 超长指令字(VLIW，Very Long Instruction Word)
    + 最大程度利用指令级并行
    + 一个超长指令字由多个互相不存在相关性的指令组成，可并行进行处理
    + 简化硬件实现，但是增加编译器的设计难度

### 1.2.2 存储管理的演变
+ 连续实地址：各程序所需的内存空间必须连续存放，并保证不与其他程序产生冲突。会造成内存碎片，难以管理多个程序。
+ 段式存储管理：将内存分为多个段和节，地址组织为相对于段地址的偏移。
+ 页式虚拟存储管理：将各进程的虚拟内存空间划分为若干长度相同的页，将虚拟地址和物理地址的对应关系组织为页表，并同经过硬件来实现快速地址转换。

### 1.2.3 运行级别的演变
+ 无管理
+ 增加保护模式：现代操作系统包含保护模式，将程序分为两个权限等级，用户态和核心态。
+ 增加调试模式：ARM 的 JTAG，MIPS 的 EJTAG
+ 增加虚拟支持：服务器领域虚拟化
+ 以 MIPS 处理器为例
    + 调试模式
    + 根模式
    + 客户模式

## 1.3 指令集结构

### 1.3.1 不同类型指令系统
+ 堆栈型：又称为零地址指令，操作数都在栈顶，在运算指令中不需要指定操作数，默认对栈顶数据进行运算并将结果压回栈顶。
+ 累加器型：又称为单地址指令，包含一个隐含操作数——累加器，另一个操作数在指令中指定，结果写会到累加器中。
+ 寄存器 - 存储器型：每个操作数都由指令显示指定，操作数为寄存器或内存地址。
+ 寄存器 - 寄存器型：
    + 所有访存都必须显式通过 load 和 store 指令来完成，又称为 load-store 型
    + 寄存器之间的相关性容易判断，容易实现流水线、多发射、乱序执行等

使用寄存器的优势，访问速度快，便于编译器的调度优化，充分利用局部性原理，大量操作可以在寄存器内完成。

### 1.3.2 操作数
+ 数据类型：char、short、int、long、long long
+ 访存地址：对齐问题和尾端问题
    + 对齐访问是指对该数据的访问起始地址和结束地址都符合其数据长度，如果只支持对齐访问，则缺少灵活性。如果不支持对齐访问，则增加复杂度。
    + 尾端问题：不同机器采用不同的尾端方式，带来数据兼容问题，最高有效字节的地址较小的是大尾端，最低有效字节的地址较小的是小尾端。
+ 寻址方式：偏移量寻址、立即数寻址和寄存器间接寻址是最常用的寻址方式，而集训期间接寻址相当于偏移量为 0 的偏移量寻址。

### 1.3.3 操作指令和编码
+ 指令分类(功能上分类)：
    + 运算指令
    + 访存指令
    + 转移指令
    + 特殊指令
+ 指令编码：操作数和操作码在整个指令码中的摆放方式
    + CISC 指令系统的指令码长度可变，依据类似赫夫曼(Huffman)编码的方式将操作码的平均长度缩小
    + RISC 指令系统的指令码长度固定，需要合理定义来保证各指令码能存放所需要的操作码、寄存器号、立即数等。

## 1.4 RISC 指令集比较

### 1.4.1 指令格式比较

在寄存器类指令中，操作码都有操作码(OP)和辅助操作码(OPX)组成，操作数都包含两个源操作数(RS)和一个目标操作数(RD)。立即数指令都由操作码、源操作数、目标操作数和立即数(const)组成，立即数的位数各有不同，跳转类指令大同小异，PA-RISC 与其他三种差别较大。

### 1.4.2 公共指令功能
+ load-store 指令，load-store 对通用寄存器进行存取操作。
+ ALU 指令，ALU 指令都是寄存器类型的，常见的 ALU 指令包括 加、减、乘、除、与、或、异或、移位、比较等
+ 控制流指令，控制流指令分为绝对跳转指令和相对跳转指令，相对跳转指令的目标地址是当前的 PC 值加上指令中的偏移量立即数，绝对跳转的目标地址直接由寄存器或指令中的立即数给出。

# 2. 特权指令系统

每一个应用程序都有自己的寄存器、内存管理以及可执行的指令。现代计算机的指令系统在用户态子集之外还定义了特权态部分，称之为特权指令系统。

不同指令系统的特权态部分差别较大，但是就其机制而言，主要分为以下几类：
+ 运行模式定义及转换
+ 虚拟存储管理
+ 异常与中断处理
+ 控制寄存器

## 2.1 异常与中断

### 2.1.1 异常分类
+ 外部事件
+ 指令执行中的错误
+ 数据完整性问题
+ 地址转换异常
+ 系统调用和陷入
+ 需要软件修正的运算

### 2.1.2 异常处理
+ 异常处理准备
+ 确定异常来源
+ 保存执行状态
+ 处理异常
+ 恢复执行状态并返回

### 2.1.3 中断
+ 中断的优先级和原子性
+ 向量化中断
+ 中断传递机制

## 2.2 存储管理

+ 原理：存储管理构建虚拟的内存地址，并通过存储管理部件(Memory Management Unit，MMU) 进行虚拟地址到物理地址的转换。

+ 作用和意义：
    + 隐藏和保护
    + 为程序分配连续的内存空间
    + 扩展地址空间
    + 节约物理内存

# 3. 软硬件协同

## 3.1 函数调用规范

ABI(Application Binary Interface) 应用程序二进制接口

ABI 通常会包含寄存器使用、函数调用、数据表示格式等约定。

MIPS 指令系统流行的 ABI 主要有三种

+ O32，传统的 MIPS 约定，广泛应用于嵌入式工具链和 32 位 Linux 中
+ N64，在 64 位处理器中使用新的正式 ABI，改变指针和 long 的宽度，并改变了寄存器使用的约定和参数传递的方式
+ N32，在 64 位处理器上执行的 32 位程序，与 N64 的区别在于指针和 long 的宽度

### 3.1.1 MIPS 堆栈布局

依据函数是否调用其他函数，可以将函数分为叶子函数和非叶子函数：

+ 叶子函数，简单堆栈函数，无须费力构造堆栈布局
+ 非叶子函数，包含其他函数调用的函数，开始时需要设置 sp 寄存器，为自己的函数分配空间并标明嵌套调用的参数结构基址
+ 复杂堆栈结构

## 3.2 系统调用过程
+ Linux 操作系统部分系统调用
    + 进程控制
    + 文件读写
    + 文件系统
    + 系统控制
    + 内存管理
    + 信号量

## 3.3 同步与通信

当线程之间出现资源访问的冲突时，需要有同步和通过新的机制来保证并发数据访问的正确性

### 3.3.1 基于互斥的同步机制

为了使得更复杂的操作具有原子性，Linux 使用锁机制，锁是对信号量机制的一种简单实现。

访问同一数据的软件都要互相协助，同一时刻只能有一个线程可以操作该数据，任何访问被锁住数据的线程将被阻塞。

### 3.3.2 非阻塞的同步机制

+ 基于锁的资源保护和线程同步的缺点
    + 若持有锁线程死亡、阻塞或死循环，其他等待锁的线程将可能永远等待下去
    + 锁机制中获取和释放锁有代码
    + 锁导致的错误与时机油管，难以重现
+ 事务内存 Transactional Memory

通过尝试性执行事务代码，在程序运行过程中动态检测事务间的冲突，并根据冲突检测结果进行提交或取消事务。

# 4.程序的转换及机器级表示

计算机的指令有微指令、机器指令和宏（伪）指令之分。

**微指令** 是微程序级命令，属于硬件范畴。

**宏指令** 是由若干机器指令组成的指令序列，属于软件范畴。

**机器指令** 是介于二者之间，处于硬件和软件的交界面。

机器指令的汇编语言表示形式为 **汇编指令** 。机器指令和汇编指令一一对应，他们都与具体的机器结构有关，都属于机器指令。

## 4.1 IA-32 指令系统概述

x86 是 Intel 开发的一种处理器体系结构的泛称。该系列中较早期的处理器以数字来表示，并以 "86" 结尾，包括 Intel 8086、80286、i386 和 i486，因此其架构被称为 "x86"。由于数字并不能作为注册商标，因此 Intel 及其竞争者均对新一代处理器使用了可注册的名称。如 Pentium、PentiumPro、Core 2、Core i7 等。

现在 Intel 把 32 位 x86 架构的名称 x86-32 该称为 IA-32，全名为 "Intel Architecture, 32-bit"。

后来由 AMD 首先提出了一个 Intel 指令集的 64 位版本，命名为 "x86-64"，它在 IA-32 的基础上对寄存器的宽度和个数、浮点运算指令等进行了扩展，并加入了一些新特性，指令能够直接处理长度为 64 位的数据。后来 AMD 将其更名为 AMD64，而 Intel 称为 Intel64。

### 4.1.1 数据类型及其格式

IA-32 中，大部分指令并不需要区分其操作数是什么类型，只是把操作数当成一个 0/1 序列来处理，所以，机器指令中只要再有相应的字段能够区分操作数的长度即可。

IA-32 中有些指令需要区分操作数类型，通常由指令操作码来区分指令操作数是带符号整数、无符号整数还是浮点数。

### 4.1.2 寄存器组织和寻址方式

不考虑 I/O 指令，IA-32 指令的操作数有三类：立即数、寄存器操作数和存储器操作数。

立即数就在指令中，无需指定其存放位置。

寄存器操作数需要制定操作数所在的寄存器的编号。

当操作数为存储单元内容时，需要制定操作数所在存储单元的地址。

IA-32 指令中用到的寄存器主要分为定点寄存器组、浮点寄存器栈和多媒体扩展寄存器。

**寻址方式**

根据指令给定信息得到操作数或操作数地址的方式称为 **寻址方式** 。

**立即寻址** 指指令中直接给出操作数。

**寄存器寻址** 指指令中给出的操作数所在的寄存器的编号。

除了立即寻址和寄存器寻址外，其他寻址方式下的操作数都在存储单元中，称为 **存储器操作数** 。

## 4.2 IA-32 常用指令类型及其操作

### 4.2.1 通用数据传送指令

通用数据传送指令传送的是寄存器或存储器中的数据。

+ MOV: 一般的传送指令，包括 movb，movw 和 movl 等
+ MOVS: 符号扩展传送指令，将短的源数据高位符号扩展后传送到目的地址，
+ MOVZ: 零扩展传送指令，将短的源数据高位零扩展后传送到目的地址。
+ XCHG: 数据交换指令，将两个寄存器内容互换。
+ PUSH: 先执行 `R[sp] <- R[sp] - 2` 或 `R[esp] <- R[esp] - 4`，然后将一个字或两字从指定寄存器送到 SP 或 ESP 指示的栈单元哄。比如 pushl 表示双字压栈，popw 表示字出栈。
+ POP: 现将一个字或双字从 SP 或 ESP 指示的栈单元送到指定寄存器中，再执行`R[sp] <- R[sp] + 2` 或 `R[esp] <- R[esp] + 4`，如 popl 表示双字出栈，popw 表示字出栈。

### 4.2.3 地址传送指令

地址传送指令传送的是操作数的存储地址，指定的目的寄存器不能是段寄存器，且源操作数必须是存储器寻址方式。

注意：这些指令均不影响标志位。主要是 **加载有效地址(Load Effect Address，LEA)** 指令，用来将源操作数的存储地址送到目的寄存器中。

### 4.2.4 输入输出指令

输入输出指令专门用于在累加器和 I/O 端口之间进行数据交换。

### 4.2.5 标志传送指令

标志传送指令专门用于对标志寄存器进行操作。

### 4.2.6 定点算术运算指令

+ 加/减运算指令

加减类(ADD/SUB)指令用于对给定长度的两个位串进行相加或相减，两个操作数中最多只能有一个是存储器操作数，不区分是无符号数还是带符号数整数，产生的和差送到目的地，生成的标志信息送到标志寄存器 FLAGS/EFLAGS。

+ 增减运算指令

增减类(INC/DEC)指令对给定长度的一个位串加 1 或减 1，给定操作数既是源操作数也是目的操作数。不区分是无符号数还是带符号整数，生成的标志信息送标志寄存器 FLAGS/EFLAGS，注意不生成 CF 标志。

+ 取负指令

取负类指令 NEG 用于求操作数的负数，就是将给定长度的一个位串 “各位取反，末尾加 1”，也称为取补指令。给定操作数既是源操作数也是目的操作数，生成的标志信息送标志寄存器 FLAGS/EFLAGS。

+ 比较指令

比较类指令 CMP 用于两个寄存器操作数的比较，用目的操作数减去源操作数，结果不送回目的操作数，即两个操作数保持原值不变，只是标志位作相应改变，因而功能类似 SUB 指令。通常该指令后面跟条件转移指令或条件设置指令。

+ 乘除运算指令

乘法指令分成 MUL(无符号数乘)和 IMUL(带符号整数乘)两类，指令中可以明显地给出一个操作数、两个操作数或三个操作数。

### 4.2.7 按位运算指令

+ 逻辑运算指令：NOT、AND、OR、XOR、TEST
+ 移位指令：逻辑左/右移、算术左/右移、循环左/右移、带循环左/右移

### 4.2.8 控制转移指令

IA-32 中执行执行的顺序由 CS 和 EIP 确定。正常情况下，指令按照它们在存储器中的存放顺序一条一条地按顺序执行，但是有些情况下，程序需要转移到另一段代码去执行，可以采用改变 CS 和 EIP，叫做 **段间转移** 或 **远转移** 转移目标的属性为 FAR，或者仅改变 EIP 的方法来实现转移，叫做 **段内转移**，分 **近转移** 和 **短转移**，转移目标的属性分别为 NEAR 或 SHORT。

段内转移和段间转移都有直接转移和间接转移之分。**直接转移** 是指转移的目标地址作为立即数直接出现在指令的机器码中。**间接转移** 则是指转移的目标地址简介存储在某一寄存器或存储单元中。

IA-32 提供了多种控制转移指令，有 无条件转移指令、条件转移指令、条件设置指令、调用/返回指令、中断指令等。

### 4.2.9 x87 浮点处理指令

IA-32 的浮点处理架构有两种：较早的一种是与 x86 配套的浮点协处理器 x87 架构，采用栈结构。另一种是由 MMX 发展而来的 SSE 指令集架构，采用的是单指令多数据(Single Instruction Multi Data，SIMD)技术，包括 SSE、SSE2、SSE3、SSE4 等。对于 IA-32 架构 GCC 默认生成 x87 指令集代码，如果想要生成 SEE 指令集代码，则需要设置适当的编译选项。

x87 FPU 有一个浮点寄存器栈，栈的深度为 8，每个浮点寄存器有 80 位。根据指令的操作功能，x87 浮点数指令可以分为浮点数装入、浮点数存储、整数浮点数转换、浮点数运算和浮点数测试比较等几种类型。

### 4.2.10 MMX/SSE 指令集

Intel 公司与 1997 年推出了 MMX(Multi Media eXtension，多媒体扩展)指令集，是一种多媒体指令增强技术，包括 57 条多媒体处理指令，通过这些指令可以一次处理多个数据。

随着网络、通信、语音、视频、图形、图像等多媒体处理软件对处理器性能越来越高的要求，Intel 在多能奔腾以后的处理器中加入了更多流式 SIMD 扩展(Stream SIMD Extension)指令集，包括 SSE、SSE2、SSE3、SSE4 等，这些都是典型的数据级并行处理技术。

SSE 兼容 MMX 指令，它可以通过 SIMD 技术在单时钟周期内并行处理 4 个单精度浮点数来有效提高浮点运算速度。


# 5. 程序转换描述

## 5.1 机器指令及汇编指令

**机器语言程序** 是一个由若干条机器指令组成的序列。每条机器指令都有若干字段组成。 **操作码字段** 用来指出指令的操作性质， **立即数字段** 是用来指出操作数或偏移量， **寄存器编号字段** 给出操作数或操作数地址所在的寄存器编号等。

为了能够直观地表示机器语言程序，引入了一种与机器语言一一对应的符号化表示语言，称为 **汇编语言** 。汇编语言用容易记忆的英文单词或缩写来表示指令操作码的含义，用标号、变量名称、寄存器名称、常数等表示操作数或地址码。这些都被称为 **汇编助记符** 。用若干个助记符表示的与机器指令意义对应的指令称为汇编指令，用汇编语言编写的程序称为 **汇编语言程序** 。

![机器指令举例](../images/机器指令举例.png)

+ 开始的 6 位 “100010” 表示的是 mov 指令。
+ 位 D 表示 reg 字段给出的是否为目的操作数，D = 1 说明 reg 字段给出的是目的操作数，否则是源操作数。
+ 位 W 表示操作数的宽度，W = 0 时为 8 位，W = 1 时为 16 位。
+ mod 字段表示的是寻址方式。
+ reg 字段是源或目的操作数所在的寄存器编号。
+ r/m 字段给出源或目的操作数所在寄存器编号，或有效地址计算方式。
+ disp8 给出在有效地址计算中用到的 8 位偏移量。

用来将汇编语言源程序中的汇编指令翻译成机器指令的程序称为 **汇编程序** 。而将机器指令反过来翻译成汇编指令的程序称为 **反汇编程序** 。

机器语言和汇编语言统称为机器级语言。用机器指令表示的机器语言程序和用汇编指令表示的汇编语言程序称为机器级程序，它是对应高级语言程序的机器级表示。

## 5.2 指令及体系结构

指令及体系结构(Instruction Set Architecture)是计算机硬件上最重要的抽象层，对使用硬件的软件屏蔽了底层硬件的实现细节，将物理上的计算机抽象为一个逻辑上的虚拟计算机，称为 **计算机语言级虚拟机** 。

ISA 定义了机器语言级虚拟机的属性和功能特性，主要包括：
+ 可执行的指令的集合，包括指令格式、操作种类以及每种操作对应的操作数的相应规定。
+ 指令可以接受的操作数的类型。
+ 操作数所能够存放的寄存器组的结构，包括每个寄存器的名称、编号、长度和用途。
+ 操作数所能够存放的存储空间的大小和编址方式。
+ 操作数在存储空间存放时按照大端方式还是小端方式存放。
+ 指令获取操作数的方式，即寻址方式。
+ 指令执行过程的控制方式，包括程序计数器、条件码定义等。

## 5.3 生成机器代码的过程

使用 GCC 将 C 语言程序转换为可执行文件，需要四个步骤：预处理、编译、汇编、链接。

+ **源文件**

C 程序 main.c

```c
#include <stdio.h>

int main() {
  printf("hello world");
  return 0;
}
```

+ **预处理**

预处理阶段：预处理程序对源程序中以字符 `#` 开头的命令进行处理，输出的结构是一个以 `.i` 为扩展名的源程序文件

对 main.c 进行预处理后，执行 `gcc -E main.c -o main.i` 命令，生成 main.i 文件

文件太大，所以直接看[预处理后的文件](../code/main.i)文件

只预处理，不编译，不链接。

+ **编译**

编译阶段：编译程序对预处理后的源程序进行编译，生成一个汇编语言源程序文件，以 `.s` 为扩展名

对 main.i 进行编译，执行 `gcc -S main.i -o main.s` 命令，生成 main.s 文件，文件里是汇编代码。

只编译，不汇编，不链接。

```acm
	.file	"main.c"
	.text
	.def	___main;	.scl	2;	.type	32;	.endef
	.section .rdata,"dr"
LC0:
	.ascii "hello world\0"
	.text
	.globl	_main
	.def	_main;	.scl	2;	.type	32;	.endef
_main:
LFB13:
	.cfi_startproc
	pushl	%ebp
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	movl	%esp, %ebp
	.cfi_def_cfa_register 5
	andl	$-16, %esp
	subl	$16, %esp
	call	___main
	movl	$LC0, (%esp)
	call	_printf
	movl	$0, %eax
	leave
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc
LFE13:
	.ident	"GCC: (MinGW.org GCC-8.2.0-5) 8.2.0"
	.def	_printf;	.scl	2;	.type	32;	.endef

```

+ **汇编**

汇编阶段：汇编程序对汇编语言进行汇编，生成一个可重定位目标文件(relocatable object file)，以 `.o` 为扩展名，是一个二进制文件，其中的代码已经是机器码。

对 main.s 进行汇编操作，执行 `gcc -c main.s -o main.o` 生成 main.o 文件，这是一个二进制文件，不能直接打开，但是可以通过 objdump 命令查看文件里的内容，执行 `objdump -d main.o` 命令，命令行输出下面内容。

编译且汇编，不链接。

`objdump -d <filename>` 的意思是反汇编，从目标文件中反汇编那些特定指令机器码的 section。

```
// objdump -d main.o

main.o:     file format pe-i386


Disassembly of section .text:

00000000 <_main>:
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   83 e4 f0                and    $0xfffffff0,%esp
   6:   83 ec 10                sub    $0x10,%esp
   9:   e8 00 00 00 00          call   e <_main+0xe>
   e:   c7 04 24 00 00 00 00    movl   $0x0,(%esp)
  15:   e8 00 00 00 00          call   1a <_main+0x1a>
  1a:   b8 00 00 00 00          mov    $0x0,%eax
  1f:   c9                      leave
  20:   c3                      ret
  21:   90                      nop
  22:   90                      nop
  23:   90                      nop
```

main.o 是重定位目标文件，所以目标代码从相对地址 0 开始，冒号前面的值表示每条指令相对于起始地址 0 的偏移量，冒号后边紧接着的是用十六进制表示的机器指令，右边是对应的汇编指令。

+ **链接**

链接阶段：链接程序将多个可重定位目标文件和标准库函数合并成为一个可执行目标文件(executable object file)，简称可执行文件。

## 5.4 程序中每条指令的执行

每个可执行文件都包含程序代码段，可执行文件的执行实际上就是对程序代码段执行的过程，程序代码段由一条一条的机器指令构成。

**指令(instruction)是用 0 和 1 表示的一串 0/1 序列，用来指示 CPU 完成一个特定的原子操作。**

+ **取数指令(load instruction)** 从存储单元中取出一个数据存放到 CPU 寄存器中。
+ **存数指令(store instruction)** 将 CPU 寄存器的内容写入一个存储单元。
+ **ALU 指令(ALU instruction)** 将两个寄存器内容进行某种算术或逻辑运算后再送入一个 CPU 寄存器中。
+ **输出指令(output instruction)** 将一个 CPU 寄存器的内容送到 IO 模块的某个缓存器中。

**指令通常被划分为若干个字段，有操作码字段、地址字段和立即数字段等。**

+ **操作码字段** 指出指令的操作类型，如加、减、传送、跳转等。
+ **地址码字段** 指出指令所处理的操作数的地址，如寄存器的编号、内存单元地址等。
+ **立即数字段** 指出具体的一个操作数或偏移地址等。

指令执行时通过控制器对指令操作码进行译码，解释成 **控制信号(control signal)** 控制数据通路执行。

**指令的执行过程：** 从存储器取出指令并计算下一条指令的地址、对指令进行译码、取操作数、对操作数进行运算、送运算结果到存储器或寄存器保存。每次从存储器取指令都将 PC 的值作为指令的地址。因此，计算出下一条要执行的指令的地址被送到 PC，当前指令执行完之后，根据 PC 的值到存储器去取下一条指令，从而能够周而复始地执行程序中的每条指令。

指令的执行由 **时钟信号(clock signal)** 进行定时，一条指令的还行可能需要一个或多个时钟的时间。
