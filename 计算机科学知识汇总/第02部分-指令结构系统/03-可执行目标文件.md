# 1. 程序的链接

## 1.1 可执行文件的生成

链接的功能是将所有关联的可重定位目标文件组合起来，以生成一个可执行文件。

可重定位目标文件和可执行目标文件都是机器语言目标文件，但是可重定位目标文件是单个模块生成的，可执行目标文件是多个模块组合而成的。因而可重定位目标文件代码总是从 0 开始，可执行目标文件代码在操作系统规定的虚拟地址空间中产生。

可重定位目标文件和可执行目标文件都是都不是可以直接显示的文本文件，而是不可显示的二进制文件，他们都按照一定的格式以二进制字节序列构成一种目标文件，其中包含二进制代码区、只读数据区、已初始化数据区和未初始化数据区等。每个信息区称为一个节(section)，如代码节(.text)、只读数据节(.rodata)、已初始化全局数据节(.data)和未初始化全局数据节(.bss)等。

静态链接器在将多个可重定位目标文件组合成一个可执行目标文件时，主要完成两个任务：

**符号解析(symbol resolution)** 符号解析的目的是将每个符号的因哟经与一个确定的符号定义建立关联。程序中有被定义和被引用的符号，这些符号包括变量名和函数名。编译器将所有符号存放在可重定位目标文件的 **符号表(symbol table)** 中，符号表是一个结构数组，每个表项包含符号名、长度和位置信息等。

**重定位** 可重定位目标文件中的代码区和数据区都是从地址 0 开始的，链接去需要将不同的模块中相同的节合并起来生成一个新的单独的节，并将合并后的代码区和数据区按照操作系统确定的 **虚拟地址空间划分(也叫存储映像)** 来重新确定位置。

使用链接的好处：
+ 模块化，使一个程序被划分成多个模块，由不同的程序员进行编写，并且可以构建公共的函数库以提供经不同的程序进行重用。
+ 效率高，每个模块可以分开编译，修改时只需要重新编译修改过的源程序文件，然后重新链接。

## 1.2 目标文件格式

**目标代码(object code)** 指编译器或汇编器处理源代码后所生成的机器语言目标代码。 **目标文件(object file)** 指存放目标代码的文件。

+ ELF(Executable and Linkable Format，可执行与可链接格式) 目标文件格式

目标文件中包含可以直接被 CPU 执行的机器代码以及代码在运行时使用的数据，还有其他的如重定位信息和调试信息。

目标文件格式既可以用于程序的链接，也可以用于程序的执行。

**链接视图** 主要由不同的节(section)组成，节是 ELF 文件中具有相同特征的最小可处理信息单位，不同的节描述了目标文件中不同类型的信息及其特征。

![ELF 链接视图](../images/ELF%20链接视图.png)

**执行视图** 主要有不同的段(segment)组成，描述了目标文件中的节如何映射到存储空间的段中，可以将多个节映射到同一个段。

![ELF 执行视图](../images/ELF%20执行视图.png)

**程序头表** 用来指示系统如何创建进程的存储器映像。用于创建进程存储器映像的可执行文件和共享库文件必须具有程序头表，而可重定位目标文件无需程序头表。

**节头表** 包含文件中各节的说明信息，每个节在该表中都有一个与之对应的项，每一项都指定了节名和节大小之类的信息。用于连接的目标文件必须具有节头表。

## 1.3 可重定位目标文件格式

可重定位目标文件主要包含代码部分和数据部分，它可以与其他可重定位目标文件链接，从而创建可执行目标文件、共享库文件或其他可重定位目标文件。

**ELF 头**

ELF 头位于目标文件的起始位置，包含文件结构说明信息，ELF 头的数据结构分 32 位系统对应结构和 64 位系统对应结构。

32 位系统对应的数据结构。

```c
#define EI_NIDENT     16

typedef struct {
    // e_ident 是一个长度为 16 字节的序列，最开始的 4 字节用来表示是否为 ELF 文件，第一个字节为 0x7F，后边三个分别是 'E'、'L'、'F'
    // 后边的 12 个字节中，包含一些标识信息，比如标识是 32 位还是 64 位，标识数据按照大端还是小端存放，表示 ELF 的版本等。
    unsigned char     e_ident[EI_NIDENT];
    // e_type 说明目标文件的类型，可重定位文件、可执行文件、共享库文件、还是其他类型的文件
    E1f32_Half        e_type;
    // e_machine 指定机器的结构类型，比如 IA-32、SPARC V9、AMD64 等
    E1f32_Half        e_machine;
    // e_version 表示目标文件的版本
    E1f32_Word        e_version;
    // e_entry 指定系统将控制权转移到的起始虚拟地址（入口点），如果文件没有关联的入口点，则为 0
    E1f32_Addr        e_entry;
    // e_phoff 
    E1f32_Off         e_phoff;
    // e_shoff 指出节头表在文件中的偏移量（以字节为单位）
    E1f32_Off         e_shoff;
    E1f32_Word        e_flags;
    // e_ehsize 用于说明 ELF 头的大小
    E1f32_Half        e_ehsize;
    // e_shentsize 表示节头表中一个表项的大小（以字节为单位），所有表项大小相同
    E1f32_Half        e_phentsize;
    E1f32_Half        e_phnum;
    E1f32_Half        e_shentsize;
    // e_shnum 表示节头表中的项数，和 e_phentsize 共同指定了节头表的大小。
    E1f32_Half        e_shnum;
    E1f32_Half        e_shstrndx;
} E1f32_Ehdr;
```

![ELF 可重定位目标文件](../images/ELF%20可重定位目标文件.png)

**节头表**

节头表由若干个表项组成，每个表项描述相应一个节的节名、位置和长度等信息，目标文件中的每个节都有一个表项与之对应。

**节**

节是 ELF 文件中的主体信息，包含了链接过程所用的目标代码信息，包括指令、数据、符号表和重定位信息等。一个典型的 ELF 可重定位目标文件包含下面几个节：
+ .text：目标代码部分。
+ .rodata：只读数据。
+ .data：已初始化的全局变量。
+ .bss：未初始化的全局变量。目标文件中区分已初始化和未初始化全局变量是为了提高空间利用率。
+ .symtab：符号表，在程序中被定义的函数名和全局变量名都属于符号，与这些符号相关的信息被保存在符号表中，每个可重定位目标文件都有一个 .symtab 节。
+ .rel.text：.text 节相关的可重定位信息。当链接器将某个目标文件和其他目标文件组合时，.text 节中的代码被合并后，一些指令中引用的操作数地址信息或跳转目标指令位置信息等都可能要修改。通常，调用外部函数或者引用全局变量的指令中的地址字段需要修改。
+ .rel.data：.data 节相关的可重定位信息。当链接器将某个目标文件和其他目标文件组合时，.data 节中的代码被合并后，一些全局变量的地址可能被修改。
+ .debug：调试用符号表，有些表项对程序中定义的局部变量和类型定义进行说明，有些表项对程序中定义和引用的全局变量进行说明。
+ .line：C 源程序中的行号和 .text 节中机器指令之间的映射。
+ .strtab：字符串表，包括 .symtab 节和 .debug 节中的符号以及节头表中的节名。字符串表就是以 null 结尾的字符串序列。

## 1.4 可执行目标文件格式

可执行目标文件由链接器将由若干个相互关联的可重定位目标文件组合生成，可重定位文件中的代码和数据的地址是相对于起始地址 0 而得到的，而可执行文件中代码和数据的地址则按照操作系统规定的存储器映像来确定起始地址，并且可重定位文件中的代码和数据的地址将会被修改，使得它们被重定位到运行时的虚拟存储空间中相应地址处。

ELF 可执行目标文件由 ELF 头、程序头表、节头表以及夹在程序头表和节头表之间的各个不同的节组成。

![ELF 可执行目标文件](../images/ELF%20可执行目标文件.png)

+ .init：定义了一个 `_init` 函数，用于可执行目标文件开始执行时的初始化工作
+ 少了两个 .rel 节，因为可执行目标文件中的指令和数据已被重定位，所以可以去掉用于重定位的节
+ 程序头表，合称为段头表(segment header table)，是一个结构数组。可执行目标文件中所有代码的位置连续，所有只读数据的位置连续，所有可读可写数据的位置连续。所以这些连续的片段(chunk)被映射到存储空间（实际上是虚拟地址空间）中的一个存储段，程序头表用于描述这种映射关系，一个表项说明一个连续的片段或一个特殊的节。

32 位系统的程序头表中每个表项的数据结构：

```c
typedef struct {
    // p_type 描述存储段的类型或特殊节的类型。比如是否可以装入段(PT_LOAD)，是否是特殊的动态节(PT_DYNAMIC)，是否是特殊的解释程序节(PT_INTERP)
    E1f32_Word    p_type;
    // p_offset 指出本段的首字节在文件中的偏移地址
    E1f32_Off     p_offset;
    // p_vaddr 指出本段首字节的虚拟地址
    E1f32_Addr    p_vaddr;
    // p_paddr 指出本段首字节的物理地址，因为物理地址由操作系统根据情况动态决定，因而该信息通常是无效的
    E1f32_Addr    p_paddr;
    // p_filesz 指出本段在文件中所占的字节数，可以是 0
    E1f32_Word    p_filesz;
    // p_memsz 指出本段在存储器中所占字节数，可以是 0
    E1f32_Word    p_memsz;
    // p_flags 指出存取权限
    E1f32_Word    p_flags;
    // p_align 指出对齐方式，有一个模数表示，为 2 的正整数幂，通常模数与页面大小相关，若页面大小为 4KB，则模数为 2 的 12 次方
    E1f32_Word    p_align;
} E1f32_Phdr;
```

## 1.5 符号表和符号解析

### 1.5.1 符号与符号表

链接器在生成一个可执行目标文件时，必须完成符号解析，而要进行符号解析，则需要用到符号表，通常目标文件中都有一个符号表，表中控包含了在程序模块中被定义的所有符号的相关信息。对于某个 C 程序模块 m 来说，包含在符号表中的符号有以下三种不同类型。

+ 在模块 m 中定义并被其他模块引用的 **全局符号(global symbol)** ，这类符号包括非静态的函数名和被定义为不带 static 属性的全局变量名。
+ 由其他模块定义并被 m 引用的 外部符号(external symbol) ，包括在其他模块定义的外部函数名和外部变量名。
+ 在模块 m 中定义并在 m 中引用的 本地符号(local symbol) ，这类符号包括带 static 属性的函数名和全局变量名。这类在一个过程（函数）内部定义的带 static 属性的本地变量不在栈中遍历，而是被分配在静态数据区，即编译器为他们在节 .data 或 .bss 中分配空间。如果模块 m 内有两个函数使用了同名 static 本地变量，则需要为这两个变量都分配空间，并作为两个不同的符号记录到符号表中。
